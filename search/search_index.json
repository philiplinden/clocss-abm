{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"clocss-abm","text":"<p>an Agent-Based Model of Heterogeneous Lunar Networks for the Cislunar Open Clock Synchronization System (CLOCSS)</p>"},{"location":"#abstract","title":"Abstract","text":"<p>This project aims to use agent-based modeling and simulations to explore how network topology and time synchronization evolve in a growing lunar ecosystem. Modeling how the approach may be used in practice and at scale informs decisions about how to architect a robust cislunar PNT system that scales with the population.</p>"},{"location":"#approach","title":"Approach","text":"<p>This project aims to use agent-based modeling and simulations to explore how centralized and decentralized PNT service network topologies evolve in a growing lunar ecosystem. Modeling network topologies representative of near-term lunar missions and large future populations of cislunar actors will predict the relative performance, \u201ccritical mass\u201d of assets required for service, and coverage of decentralized PNT services and/or GNSS-like beacons providing PNT to lunar missions. There is an abundance of prior art describing optimal orbit configurations for such systems that can also be evaluated in this way.</p> <p>The model will feature a population of agents, where each agent has a Stratum, a location and velocity, a clock with drift, and a communications system with a spectral band and radiation power. Agents belong to one of three groups based on their behavior: Transmitters, Receivers, and Peers. Transmitter agents radiate signals but do not listen for incoming signals. Receivers listen for incoming signals but do not radiate. Peers are capable of listening for and radiating signals. Agents move in space independently along orbits or surface routes around a sphere in the simulation space representing the Moon. Terrestrial communications systems are modeled as a Stratum 0 Transmitter. Every node reports measurements of each metric described in the subsequent Metrics section at every step of the simulation period.</p> <p>Over the simulation period, each agent\u2019s clock encounters simulated drift that accumulates over time. The agents record their perceived position by integrating instantaneous velocity observations over time, where the observed time is based on the local clock\u2019s epoch. At the end of the simulation period, the observed position is compared to the true position. Agents may interact with one another over the simulation period using modeled communications links for PNT measurements and time synchronization. Links are only established between two agents if both 1) share a common spectral band; 2) have line-of-sight to each other; 3) have sufficient radiation power to transmit across the distance between them; and 4) at least one agent is a Transmitter. When a link is established, the Receiver agent\u2019s clock is synchronized to the Transmitter\u2019s epoch. If both agents are Peers, the agents synchronize to the epoch of the agent with a lower Stratum, or the mean epoch between them. Each time an agent synchronizes to another agent, it becomes Stratum n+1 where Stratum n belongs to the agent with the lower number. Agent A syncs to UTC and becomes Stratum 1, then Agent B syncs to A and so Agent B becomes Stratum 2, and so on.</p> <p>This model framework permits rapid simulation of heterogeneous nodes acting as PNT servers, clients, or both. The proposed study seeks to evaluate Wi-Wi based decentralized networks as alternatives to GNSS-like services for cislunar PNT. The described model allows each network topology to be tested and instrumented while subject to realistic client population densities in near-term (tens of agents) and future scenarios (hundreds, thousands of agents). The described model also permits the simulation of multiple PNT services coexisting,  such as Parsec, weak-GPS, and the proposed decentralized network. The model also accounts for the evolution of competing providers as the populations of servers and clients grow. </p> <p>Insights obtained from models will then be applied to create an optimal mission profile for a constellation of cislunar spacecraft equipped with space-rated Time Cards that enable the proposed capability of a publicly available minimum viable PNT service. With relevant prediction of cislunar PNT users for each PNT service configuration over the next 5 to 15 years, and also computing the equivalent cost per user for terrestrial GNSS, data-driven investment decisions related to deploying new PNT fleets in cislunar space are possible.</p>"},{"location":"#metrics","title":"Metrics","text":"<p>The following metrics and quantitative evaluation criteria will be used to evaluate PNT service characteristics.</p> <p>Accuracy - Sync precision - Standard deviation absolute time across the node population - Holdover - Average clock drift from true time before syncing - Latency (jitter) - Round trip time, packet delay variation</p> <p>Availability - Capacity - % bandwidth used, peak bandwidth used, sqkm of coverage - Throughput - Total available bandwidth, # concurrent links</p> <p>Continuity - Roaming ability - # available links, time between links - Failure &amp; recovery rate - Mean time between failures, mean time to restore</p> <p>Interoperability - Standards compatibility - Meets LunaNet and Moonlight requirements - Technology compatibility - # comms spectral bands, clients served per band</p> <p>Cost - Nodes required for service - # service nodes, # clients per provider node - Hardware required - $ per clock, # clocks, $ invested per client served</p> <p>Signal Integrity - Packet integrity - packet loss rate, packet delivery ratio, % duplicate packets - Channel dominance - signal-to-noise ratio, jam-to-signal ratio</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Recent advancements in space technologies have prompted a surge in lunar missions, both crewed and uncrewed. Such an influx demands scalable, commercially-accessible Positioning, Navigation, and Timing (PNT) frameworks for the development of a cislunar economy. In order to bring PNT infrastructure to the lunar ecosystem and have it be as ubiquitous and as useful as Global Navigation Satellite Systems (GNSS) are in the interoperable Space Service Volume (SSV), there needs to be accurate, traceable and accessible timing and ranging infrastructure that is also resilient, reliable and flexible. NASA\u2019s LunaNet and ESA\u2019s Moonlight are two major initiatives to promote interoperability and connectivity in cislunar space by providing a common communications framework and standards. Lunar constellations equivalent to terrestrial GNSS are one approach to delivering a cislunar PNT but it is not the only solution. Peer-to-peer networks of satellites with precision timekeeping may serve as an alternative method of implementing a PNT service to traditional GNSS constellations.</p> <p>This project will use agent-based modeling to compare satellite network topologies using metrics known from the current PNT solution such as accuracy, availability, continuity and integrity, in addition to costs, timeline and technology development requirements of implementing each system in a cislunar context. The goal is to develop the proposed solution to a level mature enough to predict the system\u2019s performance relative to the number and distribution of interconnected assets, and quantitatively demonstrate that our approach becomes more robust and performant as it scales to service the anticipated demands of a thriving lunar ecosystem. The study will also consider specific lunar PNT user needs and infrastructure combination opportunities, as well as requirements for Earth / Earth Orbit systems to be usable with minimum changes for lunar applications.</p>"},{"location":"#diverse-cislunar-ecosystems-of-pnt-and-communications-infrastructures-are-inevitable","title":"Diverse Cislunar Ecosystems of PNT and Communications Infrastructures are Inevitable","text":"<p>A fundamental characteristic of the this proposed design is its peer-to-peer topology, ensuring resilience against centralized points of failure. The structure stands robust against interference, adversarial or accidental. The decentralized nature of the design further augments its flexibility, permitting in-flight mission adaptations and potential as a backup for lunar missions, reducing their dependence on individualized PNT structures. Since Wi-Wi is a protocol that works with any radio band, it is likely that several independent PNT services could emerge on different parts of the spectrum. This allows actors to maintain closed PNT utilities or to offer services for a self-sustaining, monetizable, commercially owned-and-operated lunar infrastructure. Critically, public and private PNT utilities may coexist under this paradigm, like how a single transponder can access both terrestrial open-air radio and encrypted radio channels. In essence, this philosophy aims to nurture a resilient PNT ecosystem that accommodates both public and private ventures. Through a credibly neutral protocol for timekeeping, bad actors would not only have difficulty manipulating the service, but they may use this infrastructure themselves and even work to support its canonization.</p>"},{"location":"#interoperability-with-other-missions","title":"Interoperability with Other Missions","text":"<p>In the design of a lunar PNT system one important consideration is the definition of a reference frame to allow for absolute position. This time transfer and relative position concept could be used to define a network of realization points (fixed points for the reference frame) to assist in the realization of a Lunar Reference Frame. These lunar realization points would be located on the near side of the Moon and equipped with e.g., laser retroreflectors for accurate ranging from Earth by the existing Lunar Laser Ranging (LLR) stations. Like GNSS, passive receivers can obtain the time and position in reference to the PNT node\u2019s position by observing the transmitted signal so long as the receiver\u2019s clock is synchronized to the node.</p>"},{"location":"captains_log/","title":"Captain's Log","text":""},{"location":"captains_log/#2023-11-17-pl","title":"2023-11-17 - PL","text":"<p>Objective: start the network model.</p>"},{"location":"captains_log/#summary","title":"Summary","text":"<ul> <li>Moved the spatial components to <code>orbits.py</code>.</li> <li>Added additional documentation packages: <code>mkdocs-material</code> and <code>mkautodocs</code>.</li> <li>Refreshed the look and feel of the docs pages.</li> </ul>"},{"location":"captains_log/#notes","title":"Notes","text":"<p>This model has two main components: the motion model and the network model. I'm going to try to keep this in mind as I organize (and re-organize) the codebase.</p> <p>Hm, elements are more tightly coupled than I anticipated. <code>OrbitsModel</code> needs a set of <code>SpacecraftAgent</code>s to run. The <code>SpacecraftAgent</code>s will be the agents that perform actions and such. Maybe there's a way to add inheritance to things so that the agents can inherit from a timekeeping agent and an orbiting agent, and so on. I'm going to segment it off and develop a timekeeping agent separately, then combine them in a refactor effort whats all the machinery is up and running.</p> <p>In the end I decided to put UI components in <code>server.py</code>. This way, all of the visualizations are together. The various model components will be imported by <code>model.py</code> as a nexus of sorts (or perhaps an interface?) for the server to reach all the various components that will probably show up later. I guess it is also a rug to sweep messes under...</p> <p>One thing that seems to be missing is code docs (not just authored docs). I found an interesting package called mkdocstrings that supposedly automates this and integrates with MkDocs and is especially tailored for the Material for MkDocs theme. When searching for docs here, I also found a nifty little package called <code>mkdocs-click</code> for beautifying Click CLI docs.</p>"},{"location":"captains_log/#2023-11-15-pl","title":"2023-11-15 - PL","text":"<p>Objective: report issues with nyx.</p>"},{"location":"captains_log/#summary_1","title":"Summary","text":"<ul> <li>Reported issue in Nyx Python: #250</li> <li>Got Nyx monte carlo orbits working: notebooks/monte_carlo.ipynb</li> <li>Re-implemented the monte carlo orbit generation in the Mesa model</li> <li>Set the server default values to approximate ISS orbit</li> </ul>"},{"location":"captains_log/#notes_1","title":"Notes","text":"<p>While trying to show how the monte carlo functions weren't working, I proved myself wrong (in a good way). As shown by notebooks/monte_carlo.ipynb The distributions in SMA and Inclination both work. I didn't have as much luck with eccentricity, but other parameters worked just fine. I re-integrated the monte carlo orbit generation into the agent generation code. It's much quicker.</p>"},{"location":"captains_log/#2023-11-13-pl","title":"2023-11-13 - PL","text":"<p>Objective: clean up the repo.</p>"},{"location":"captains_log/#summary_2","title":"Summary","text":"<ul> <li>Organization tweaks</li> <li>Refactored the \"monte carlo\" distributions of orbits because the sliders   didn't work</li> </ul>"},{"location":"captains_log/#notes_2","title":"Notes","text":"<p>The code got really messy as I was tinkering and trying to get the visualization and Nyx to work. I should clean up the code before things get out of hand.</p> <p>On the topic of rendering plotly figures from the Mesa server, perhaps I can make use of <code>plotly.io.to_json</code> and <code>plotly.io.from_json</code> to pass on the figure data to a canvas. For example, create a simple canvas class that accepts the figure data as a JSON and a subclass of <code>VisualizationElement</code> that renders the plotly figure from json data.</p> <p>I discovered that the distribution tweakables for changing agent orbits was completely broken. For some reason, only SMA was changing when adjusting input parameters to the Nyx monte carlo functions. Changing inclination and eccentricity didn't actually have an effect. Since this is just meant to introduce some variation between the agents' orbits, I abandoned the Nyx built-ins and used simple gaussian distributions to vary the orbital elements as each agent is created. The sliders now influence the width of these distribution functions.</p> <p>Similarly, changing the mean inclination, raan, or argument of periapsis had no effect on the orbits that were created by the Nyx monte carlo functions. Turns out this is because the monte carlo generator initializes with a default orbit and I couldn't figure out how to modify this parameter. When I supplied a custom orbit to <code>generate_orbits()</code> as an argument, it seemed to be ignored. Rather than debug Nyx, I abandoned this function.</p>"},{"location":"captains_log/#2023-11-12-pl","title":"2023-11-12 - PL","text":"<p>Objective: plot trajectories.</p>"},{"location":"captains_log/#summary_3","title":"Summary","text":"<ul> <li>Added simple latitude/longitude visualization to the server.</li> </ul>"},{"location":"captains_log/#notes_3","title":"Notes","text":"<p>It's hard to judge the nyx propagations of agents without a visualization. So let's add some. There are two \"easy\" plots to make: line plots and the plots built in to Nyx.</p> <p>Took me a while but I finally made a simple grid portrayal for the satellites. To get it done, I borrowed continuous space visualizations from the Mesa example boid flockers.</p> <p>Now that I know I can model trajectories, I'm going to scale back and focus on the agent interactions. After a working demo of that, I'll merge the two demos and we have our first real satellite sim.</p>"},{"location":"captains_log/#adding-a-data-collector-to-the-model","title":"Adding a data collector to the model","text":"<p>The <code>mesa.DataCollector</code> class init function lets us define reporters from each agent using lambda functions, so let's use that to grab some orbit information.</p>"},{"location":"captains_log/#2023-11-11-pl","title":"2023-11-11 - PL","text":"<p>Objective: define a timekeeper agent and preliminary environment.</p>"},{"location":"captains_log/#summary_4","title":"Summary","text":"<ul> <li>Removed example code.</li> <li>Built a toy example following the mesa.readthedocs.io tutorials:   sandbox.ipynb</li> <li>Decided to keep iterating on Python to learn, but may eventually switch to   Rust for speed if necessary.</li> <li>Used Nyx tests as a boilerplate for invoking the Nyx API<ul> <li>Created spacecraft objects</li> <li>Propagated orbits forward in time</li> </ul> </li> <li>Created a basic tunable Mesa server with monte carlo spacecraft agents</li> </ul>"},{"location":"captains_log/#notes_4","title":"Notes","text":"<p>The tutorials suggest using an interactive environment to begin, and I agree that it's for the best. The server is a whole other beast and it's too much at once to deal with them both for now.</p> <p>The Python documentation for nyx is very rust-centric. I can probably get by from referencing the Python source. Looks like hifitime Python docs are a bit more mature, but still mostly focused on the rust crate. Should I pivot to rust? There are ABM frameworks for rust that are plug-and-play...</p> <ul> <li>Mesa (Python): Masad, et. al. (2015)</li> <li>krABMaga (Rust): Antelmi, et. al. (2019)</li> </ul> <p>For now I'll stick with Python for ease of use. If I run into performance bottlenecks, it shouldn't be terribly hard to port the meat of the model to a rust framework.</p> <p>In the absence of docs, the next best place to look for boilerplate code to get me started with Nyx is in the tests. As a simple demo, we'll propagate orbits as the simulation progresses or something.</p>"},{"location":"captains_log/#2023-11-10-pl","title":"2023-11-10 - PL","text":"<p>Objective: block out the project structure.</p>"},{"location":"captains_log/#summary_5","title":"Summary","text":"<ul> <li>Initialized the project metadata and dependencies with Python Poetry</li> <li>Added docs via MkDocs</li> <li>Set up a working example from mesa-examples</li> </ul>"},{"location":"captains_log/#notes_5","title":"Notes","text":"<p>I know it's too early to really have documentation or a package manager but Poetry and MkDocs are so easy so might as well. Besides, they make the whole project feel so professional, so there's really no reason not to.</p> <p>As for Mesa, the examples library is great for validating the setup and establishing a boilerplate project setup. The website also has Best Practices but it's basically just \"use a readme and these file names\".</p>"},{"location":"example/","title":"Orbit Monte Carlo with Nyx","text":""},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#clocss.comms","title":"<code>comms</code>","text":"<p>comms</p> <p>This module defines components related to agents talking to each other.</p>"},{"location":"reference/#clocss.model","title":"<code>model</code>","text":"<p>model</p> <p>This module contains the highest level structures that define the model, as  recommended by Mesa: https://mesa.readthedocs.io/en/stable/best-practices.html</p>"},{"location":"reference/#clocss.orbits","title":"<code>orbits</code>","text":"<p>orbits</p> <p>Components in this module define spatial elements</p>"},{"location":"reference/#clocss.orbits.OrbitsModel","title":"<code>OrbitsModel</code>","text":"<p>             Bases: <code>Model</code></p> <p>A model with some number of agents</p> Source code in <code>clocss/orbits.py</code> <pre><code>class OrbitsModel(mesa.Model):\n    \"\"\"A model with some number of agents\"\"\"\n\n    def __init__(\n        self,\n        num_actors: int,\n        epoch: str,\n        delta_t: float = 60.0,\n        sma: float = 500,\n        ecc: float = 1e-4,\n        inc_deg: float = 30.5,\n        raan_deg: float = 35.0,\n        aop_deg: float = 65.0,\n        ta_deg: float = 590,\n        monte_sma: float = 5,\n        monte_raan: float = 10,\n    ):\n        if num_actors &lt; 1:\n            raise ValueError('Must have at least one agent')\n\n        # Create a scheduler and simulation space\n        self.schedule = mesa.time.RandomActivation(self)\n        self.space = mesa.space.ContinuousSpace(\n            x_min=0, x_max=360, y_min=-90, y_max=90, torus=True)\n\n        # create the generic orbit and spacecraft\n        cosm = Cosm.de438()\n        eme2k = cosm.frame(\"EME2000\")\n        dynamics = SpacecraftDynamics.load(\"clocss/data/dynamics.yaml\")\n        e = Epoch(epoch)\n        template_orbit = Orbit.from_keplerian_altitude(\n            sma_altitude_km=sma,\n            ecc=ecc,\n            inc_deg=inc_deg,\n            raan_deg=raan_deg,\n            aop_deg=aop_deg,\n            ta_deg=ta_deg,\n            epoch=e,\n            frame=eme2k,\n        )\n        dry_mass_kg = 100\n\n        orbits = generate_orbits(\n            template_orbit,\n            [\n                (StateParameter.SMA, monte_sma),\n                (StateParameter.RAAN, monte_raan),\n            ],\n            num_actors,\n            kind='abs',\n        )\n        # Create a list of spacecraft agents\n        for uid, orbit in enumerate(orbits):\n            sc = Spacecraft(orbit, dry_mass_kg, 0)\n            a = SpacecraftAgent(self, uid, sc, Unit.Second * float(delta_t),\n                                dynamics)\n            self.space.place_agent(a, (a.longitude, a.latitude))\n            self.schedule.add(a)\n\n    def step(self):\n        \"\"\"Advance the model by one step.\"\"\"\n        log.warn(\"Step!\")\n        # The model's step will go here for now this will call the step method\n        # of each agent and print the agent's unique_id\n        self.schedule.step()\n</code></pre>"},{"location":"reference/#clocss.orbits.OrbitsModel.step","title":"<code>step()</code>","text":"<p>Advance the model by one step.</p> Source code in <code>clocss/orbits.py</code> <pre><code>def step(self):\n    \"\"\"Advance the model by one step.\"\"\"\n    log.warn(\"Step!\")\n    # The model's step will go here for now this will call the step method\n    # of each agent and print the agent's unique_id\n    self.schedule.step()\n</code></pre>"},{"location":"reference/#clocss.orbits.SpacecraftAgent","title":"<code>SpacecraftAgent</code>","text":"<p>             Bases: <code>Agent</code></p> <p>An agent that keeps time</p> Source code in <code>clocss/orbits.py</code> <pre><code>class SpacecraftAgent(mesa.Agent):\n    \"\"\"An agent that keeps time\"\"\"\n\n    def __init__(\n        self,\n        model: mesa.Model,\n        unique_id: int,\n        spacecraft: Spacecraft,\n        delta_t: Duration,\n        dynamics: SpacecraftDynamics,\n    ):\n        # pass the parameters to the parent class\n        super().__init__(unique_id, model)\n        self.spacecraft = spacecraft\n        self.delta_t = delta_t\n        self.dyn = dynamics\n        self.traj = None\n        self.update()\n        log.debug(f\"Initialized agent {self.unique_id}\")\n\n    def update(self):\n        self.epoch = self.spacecraft.epoch\n        self.longitude = self.spacecraft.orbit.geodetic_longitude_deg()\n        self.latitude = self.spacecraft.orbit.geodetic_latitude_deg()\n        self.x = self.spacecraft.orbit.geodetic_longitude_deg()\n        self.y = self.spacecraft.orbit.geodetic_latitude_deg()\n        log.info(pformat({'id': self.unique_id,\n            'latlon': (self.latitude, self.longitude),\n            'orbit': str(self.spacecraft.orbit),\n        }))\n\n    def move(self):\n        self.model.space.move_agent(self, (self.x, self.y))\n\n    def step(self):\n        \"\"\"what happens when the sim ticks forward\"\"\"\n        self.spacecraft, self.traj = propagate(self.spacecraft, self.dyn, self.delta_t)\n        self.update()\n        self.move()\n</code></pre>"},{"location":"reference/#clocss.orbits.SpacecraftAgent.step","title":"<code>step()</code>","text":"<p>what happens when the sim ticks forward</p> Source code in <code>clocss/orbits.py</code> <pre><code>def step(self):\n    \"\"\"what happens when the sim ticks forward\"\"\"\n    self.spacecraft, self.traj = propagate(self.spacecraft, self.dyn, self.delta_t)\n    self.update()\n    self.move()\n</code></pre>"},{"location":"reference/#clocss.server","title":"<code>server</code>","text":"<p>server</p> <p>This module contains visualizations and the server itself, as recommended by Mesa: https://mesa.readthedocs.io/en/stable/best-practices.html</p>"},{"location":"reference/#clocss.server.satellite_portrayal","title":"<code>satellite_portrayal(agent)</code>","text":"<p>Define a portrayal for a SpacecraftAgent</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>SpacecraftAgent</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>description</p> Source code in <code>clocss/server.py</code> <pre><code>def satellite_portrayal(agent: SpacecraftAgent) -&gt; dict:\n    \"\"\"Define a portrayal for a SpacecraftAgent\n\n    Args:\n        agent (SpacecraftAgent): _description_\n\n    Returns:\n        dict: _description_\n    \"\"\"\n\n    # update portrayal characteristics for each satellite object\n    return Circle(\n        r = 1,\n        Layer = 0,\n        Color = \"#2596be\",\n        x = agent.x,\n        y = agent.y,\n    ).to_dict()\n</code></pre>"},{"location":"reference/#clocss.tools","title":"<code>tools</code>","text":""},{"location":"reference/#clocss.tools.LogFormatter","title":"<code>LogFormatter</code>","text":"<p>             Bases: <code>Formatter</code></p> <p>Logging Formatter to add colors and count warning / errors</p> Source code in <code>clocss/tools/__init__.py</code> <pre><code>class LogFormatter(logging.Formatter):\n    \"\"\"Logging Formatter to add colors and count warning / errors\"\"\"\n\n    def __init__(self):\n        super(LogFormatter, self).__init__()\n        module = f\"{Colors.BLUE}%(module)-6s{Colors.RESET} \"\n        lvl = f\"{Colors.BOLD}%(levelname)+8s:{Colors.END} \"\n        msg = \"%(message)s\"\n        self.FORMATS = {\n            logging.DEBUG: module\n            + Colors.PURPLE\n            + lvl\n            + Colors.PURPLE\n            + msg\n            + Colors.RESET,\n            logging.INFO: module + Colors.GREY + lvl + Colors.GREY + msg + Colors.RESET,\n            logging.WARNING: module\n            + Colors.YELLOW\n            + lvl\n            + Colors.YELLOW\n            + msg\n            + Colors.RESET,\n            logging.ERROR: module + Colors.RED + lvl + Colors.RED + msg + Colors.RESET,\n            logging.CRITICAL: module\n            + Colors.BLINK_RED\n            + lvl\n            + Colors.BLINK_RED\n            + msg\n            + Colors.RESET,\n        }\n\n    def format(self, record):\n        log_fmt = self.FORMATS.get(record.levelno)\n        formatter = logging.Formatter(log_fmt)\n        return formatter.format(record)\n</code></pre>"},{"location":"reference/#clocss.tools.visualizations","title":"<code>visualizations</code>","text":"<p>visualizations</p> <p>Define visual elements that can be rendered on a Mesa ModularServer. These elements are generic.</p>"},{"location":"reference/#clocss.tools.visualizations.log","title":"<code>log = logging.getLogger()</code>  <code>module-attribute</code>","text":"<p>\"x\", \"y\": Coordinates for the cell in which the object is placed. \"Shape\": Can be either \"circle\", \"rect\", \"arrowHead\" or a custom image.     For Circles:         For Rectangles:             \"w\", \"h\": The width and height of the rectangle, which are in                         fractions of cell width and height.             \"xAlign\", \"yAlign\": Alignment of the rectangle within the                                 cell. Defaults to 0.5 (center).         For arrowHead:             \"scale\": Proportion scaling as a fraction of cell size.             \"heading_x\": represents x direction unit vector.             \"heading_y\": represents y direction unit vector.             For an image:             The image must be placed in the same directory from which the             server is launched. An image has the attributes \"x\", \"y\",             \"scale\", \"text\" and \"text_color\".</p>"},{"location":"reference/#clocss.tools.visualizations.CanvasContinuous","title":"<code>CanvasContinuous</code>","text":"<p>             Bases: <code>VisualizationElement</code></p> <p>Continuous space canvas</p> <p>This element is intended to work just like CanvasMultiGrid but for continuous spaces.</p> <p>adapted from mesa examples     examples/boid_flockers/boid_flockers/SimpleContinuousModule.py</p> Source code in <code>clocss/tools/visualizations.py</code> <pre><code>class CanvasContinuous(VisualizationElement):\n    \"\"\"Continuous space canvas\n\n    This element is intended to work just like CanvasMultiGrid but for\n    continuous spaces.\n\n    adapted from mesa examples\n        examples/boid_flockers/boid_flockers/SimpleContinuousModule.py\n    \"\"\"\n\n    local_includes = [\"clocss/tools/simple_continuous_canvas.js\"]\n    portrayal_method = None\n    canvas_height = 500\n    canvas_width = 500\n\n    def __init__(\n        self,\n        portrayal_method: Callable,\n        canvas_height: int = 500,\n        canvas_width: int = 500,\n    ):\n        \"\"\"Instantiate a continuous canvas\n\n        A portrayal is a dictionary with the following structure:\n        \"x\", \"y\": Coordinates for the cell in which the object is placed.\n        \"Shape\": Can be either \"circle\", \"rect\", \"arrowHead\" or a custom image.\n            For Circles:\n                \"r\": The radius, defined as a fraction of cell size. r=1 will\n                     fill the entire cell.\n                \"xAlign\", \"yAlign\": Alignment of the circle within the cell.\n                                    Defaults to 0.5 (center).\n            For Rectangles:\n                \"w\", \"h\": The width and height of the rectangle, which are in\n                          fractions of cell width and height.\n                \"xAlign\", \"yAlign\": Alignment of the rectangle within the\n                                    cell. Defaults to 0.5 (center).\n        \"Color\": The color to draw the shape in; needs to be a valid HTML\n                 color, e.g.\"Red\" or \"#AA08F8\"\n        \"Filled\": either \"true\" or \"false\", and determines whether the shape is\n                  filled or not.\n        \"Layer\": Layer number of 0 or above; higher-numbered layers are drawn\n                 above lower-numbered layers.\n        \"text\": The text to be inscribed inside the Shape. Normally useful for\n                showing the unique_id of the agent.\n        \"text_color\": The color to draw the inscribed text. Should be given in\n                      conjunction of \"text\" property.\n\n        Args:\n            portrayal_method (Callable): function that takes an agent and\n                returns a portrayal dict\n            canvas_height (int, optional): Height of canvas area in pixels.\n                Defaults to 500.\n            canvas_width (int, optional): Width of canvas area in pixels.\n                Defaults to 500.\n        \"\"\"\n        self.portrayal_method = portrayal_method\n        self.canvas_height = canvas_height\n        self.canvas_width = canvas_width\n        new_element = \"new Simple_Continuous_Module({}, {})\".format(\n            self.canvas_width, self.canvas_height\n        )\n        self.js_code = \"elements.push(\" + new_element + \");\"\n\n    def render(self, model):\n        space_state = []\n        if not self.portrayal_method:\n            return space_state\n        for obj in model.schedule.agents:\n            portrayal = self.portrayal_method(obj)\n            x, y = obj.pos\n            x_min = model.space.x_min\n            x_max = model.space.x_max\n            y_min = model.space.y_min\n            y_max = model.space.y_max\n            scaled_x = (x - x_min) / (x_max - x_min)\n            scaled_y = (y - y_min) / (y_max - y_min)\n            portrayal[\"x\"] = scaled_x\n            portrayal[\"y\"] = scaled_y\n            space_state.append(portrayal)\n        return space_state\n</code></pre>"},{"location":"reference/#clocss.tools.visualizations.CanvasContinuous.__init__","title":"<code>__init__(portrayal_method, canvas_height=500, canvas_width=500)</code>","text":"<p>Instantiate a continuous canvas</p> <p>A portrayal is a dictionary with the following structure: \"x\", \"y\": Coordinates for the cell in which the object is placed. \"Shape\": Can be either \"circle\", \"rect\", \"arrowHead\" or a custom image.     For Circles:         \"r\": The radius, defined as a fraction of cell size. r=1 will              fill the entire cell.         \"xAlign\", \"yAlign\": Alignment of the circle within the cell.                             Defaults to 0.5 (center).     For Rectangles:         \"w\", \"h\": The width and height of the rectangle, which are in                   fractions of cell width and height.         \"xAlign\", \"yAlign\": Alignment of the rectangle within the                             cell. Defaults to 0.5 (center). \"Color\": The color to draw the shape in; needs to be a valid HTML          color, e.g.\"Red\" or \"#AA08F8\" \"Filled\": either \"true\" or \"false\", and determines whether the shape is           filled or not. \"Layer\": Layer number of 0 or above; higher-numbered layers are drawn          above lower-numbered layers. \"text\": The text to be inscribed inside the Shape. Normally useful for         showing the unique_id of the agent. \"text_color\": The color to draw the inscribed text. Should be given in               conjunction of \"text\" property.</p> <p>Parameters:</p> Name Type Description Default <code>portrayal_method</code> <code>Callable</code> <p>function that takes an agent and returns a portrayal dict</p> required <code>canvas_height</code> <code>int</code> <p>Height of canvas area in pixels. Defaults to 500.</p> <code>500</code> <code>canvas_width</code> <code>int</code> <p>Width of canvas area in pixels. Defaults to 500.</p> <code>500</code> Source code in <code>clocss/tools/visualizations.py</code> <pre><code>def __init__(\n    self,\n    portrayal_method: Callable,\n    canvas_height: int = 500,\n    canvas_width: int = 500,\n):\n    \"\"\"Instantiate a continuous canvas\n\n    A portrayal is a dictionary with the following structure:\n    \"x\", \"y\": Coordinates for the cell in which the object is placed.\n    \"Shape\": Can be either \"circle\", \"rect\", \"arrowHead\" or a custom image.\n        For Circles:\n            \"r\": The radius, defined as a fraction of cell size. r=1 will\n                 fill the entire cell.\n            \"xAlign\", \"yAlign\": Alignment of the circle within the cell.\n                                Defaults to 0.5 (center).\n        For Rectangles:\n            \"w\", \"h\": The width and height of the rectangle, which are in\n                      fractions of cell width and height.\n            \"xAlign\", \"yAlign\": Alignment of the rectangle within the\n                                cell. Defaults to 0.5 (center).\n    \"Color\": The color to draw the shape in; needs to be a valid HTML\n             color, e.g.\"Red\" or \"#AA08F8\"\n    \"Filled\": either \"true\" or \"false\", and determines whether the shape is\n              filled or not.\n    \"Layer\": Layer number of 0 or above; higher-numbered layers are drawn\n             above lower-numbered layers.\n    \"text\": The text to be inscribed inside the Shape. Normally useful for\n            showing the unique_id of the agent.\n    \"text_color\": The color to draw the inscribed text. Should be given in\n                  conjunction of \"text\" property.\n\n    Args:\n        portrayal_method (Callable): function that takes an agent and\n            returns a portrayal dict\n        canvas_height (int, optional): Height of canvas area in pixels.\n            Defaults to 500.\n        canvas_width (int, optional): Width of canvas area in pixels.\n            Defaults to 500.\n    \"\"\"\n    self.portrayal_method = portrayal_method\n    self.canvas_height = canvas_height\n    self.canvas_width = canvas_width\n    new_element = \"new Simple_Continuous_Module({}, {})\".format(\n        self.canvas_width, self.canvas_height\n    )\n    self.js_code = \"elements.push(\" + new_element + \");\"\n</code></pre>"},{"location":"reference/#clocss.tools.visualizations.Circle","title":"<code>Circle</code>  <code>dataclass</code>","text":"<p>             Bases: <code>PrimitiveShape</code></p> <p>\"r\": The radius, defined as a fraction of cell size. r=1 will         fill the entire cell.</p> Source code in <code>clocss/tools/visualizations.py</code> <pre><code>@dataclass\nclass Circle(PrimitiveShape):\n    \"\"\"\n    \"r\": The radius, defined as a fraction of cell size. r=1 will\n            fill the entire cell.\n    \"\"\"\n    Shape: str = 'circle'\n    r: float = 1\n</code></pre>"},{"location":"reference/#clocss.tools.visualizations.PrimitiveShape","title":"<code>PrimitiveShape</code>  <code>dataclass</code>","text":"<p>\"x\", \"y\": Coordinates for the cell in which the object is placed. \"Shape\": Can be either \"circle\", \"rect\", \"arrowHead\" or a custom image.     Note: only \"circle\" and \"rect\" are supported by Continuous Canvas \"Layer\": which canvas layer to draw the shape on \"xAlign\", \"yAlign\": Alignment of the shape within the cell.                     Defaults to 0.5 (center).</p> Source code in <code>clocss/tools/visualizations.py</code> <pre><code>@dataclass\nclass PrimitiveShape:\n    \"\"\"\n    \"x\", \"y\": Coordinates for the cell in which the object is placed.\n    \"Shape\": Can be either \"circle\", \"rect\", \"arrowHead\" or a custom image.\n        Note: only \"circle\" and \"rect\" are supported by Continuous Canvas\n    \"Layer\": which canvas layer to draw the shape on\n    \"xAlign\", \"yAlign\": Alignment of the shape within the cell.\n                        Defaults to 0.5 (center).\n    \"\"\"\n    x: float\n    y: float\n    Layer: int = 0\n    Color: str = \"#2596be\"\n    Filled: str = 'true'\n    xAlign: float = 0.5\n    yAlign: float = 0.5\n\n    def to_dict(self):\n        return asdict(self)\n</code></pre>"},{"location":"reference/#clocss.tools.visualizations.Rectangle","title":"<code>Rectangle</code>  <code>dataclass</code>","text":"<p>             Bases: <code>PrimitiveShape</code></p> <p>\"w\", \"h\": The width and height of the rectangle, which are in             fractions of cell width and height.</p> Source code in <code>clocss/tools/visualizations.py</code> <pre><code>@dataclass\nclass Rectangle(PrimitiveShape):\n    \"\"\"\n    \"w\", \"h\": The width and height of the rectangle, which are in\n                fractions of cell width and height.\n    \"\"\"\n    Shape: str = 'rect'\n    w: float = 1\n    h: float = 1\n</code></pre>"}]}